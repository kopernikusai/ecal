
.. _program_listing_file_ecal_core_include_ecal_ecal_publisher.h:

Program Listing for File ecal_publisher.h
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file_ecal_core_include_ecal_ecal_publisher.h>` (``ecal/core/include/ecal/ecal_publisher.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /* ========================= eCAL LICENSE =================================
    *
    * Copyright (C) 2016 - 2019 Continental Corporation
    *
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    * 
    *      http://www.apache.org/licenses/LICENSE-2.0
    * 
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    *
    * ========================= eCAL LICENSE =================================
   */
   
   #pragma once
   
   #include <ecal/ecal_os.h>
   #include <ecal/ecal_callback.h>
   #include <ecal/ecal_qos.h>
   #include <ecal/ecal_tlayer.h>
   
   #include <string>
   
   #ifndef ECAL_C_DLL
   
   namespace eCAL
   {
     class CDataWriter;
   
     class ECAL_API CPublisher
     {
     public:
       CPublisher();
   
       CPublisher(const std::string& topic_name_, const std::string& topic_type_ = "", const std::string& topic_desc_ = "");
   
       virtual ~CPublisher();
   
       CPublisher(const CPublisher&) = delete;
   
       CPublisher& operator=(const CPublisher&) = delete;
   
       CPublisher(CPublisher&& rhs) noexcept;
   
       CPublisher& operator=(CPublisher&& rhs) noexcept;
   
       bool Create(const std::string& topic_name_, const std::string& topic_type_ = "", const std::string& topic_desc_ = "");
   
       bool Destroy();
   
       bool SetDescription(const std::string& topic_desc_);
   
       bool ShareType(bool state_ = true);
   
       bool ShareDescription(bool state_ = true);
   
       bool SetQOS(const QOS::SWriterQOS& qos_);
   
       QOS::SWriterQOS GetQOS();
   
       bool SetLayerMode(TLayer::eTransportLayer layer_, TLayer::eSendMode mode_);
   
       bool SetMaxBandwidthUDP(long bandwidth_);
   
       bool SetID(long long id_);
   
       size_t Send(const void* const buf_, size_t len_, long long time_ = -1) const;
   
       size_t Send(const std::string& s_, long long time_ = -1) const;
   
       bool AddEventCallback(eCAL_Publisher_Event type_, PubEventCallbackT callback_);
   
       bool RemEventCallback(eCAL_Publisher_Event type_);
   
       bool IsCreated() const {return(m_created);}
   
       bool IsSubscribed() const;
   
       std::string GetTopicName() const;
   
       std::string GetTypeName() const;
   
       std::string GetDescription() const;
   
       std::string Dump(const std::string& indent_ = "") const;
   
     protected:
       void InitializeQOS();
       void InitializeTLayer();
   
       // class members
       CDataWriter*                     m_datawriter;
       struct ECAL_API QOS::SWriterQOS  m_qos;
       struct ECAL_API TLayer::STLayer  m_tlayer;
       long long                        m_id;
       bool                             m_created;
       bool                             m_initialized;
     };
   };
   
   #else /* ! ECAL_C_DLL */
   
   #include <ecal/ecalc.h>
   
   namespace eCAL
   {
     class CPublisher
     {
     public:
       CPublisher() :
         m_publisher(nullptr),
         m_id(0),
         m_created(false)
       {
         InitializeQOS();
         InitializeTLayer();
       }
   
       CPublisher(const std::string& topic_name_, const std::string& topic_type_ = "", const std::string& topic_desc_ = "") :
         m_publisher(nullptr),
         m_id(0),
         m_created(false)
       {
         InitializeQOS();
         InitializeTLayer();
   
         Create(topic_name_, topic_type_, topic_desc_);
       }
   
       virtual ~CPublisher()
       {
         Destroy();
       }
   
       // this object must not be copied.
       CPublisher(const CPublisher&) = delete;
       CPublisher& operator=(const CPublisher&) = delete;
   
       CPublisher(CPublisher&& rhs)
         : m_publisher(rhs.m_publisher)
         , m_topic_name(std::move(rhs.m_topic_name))
         , m_topic_type(std::move(rhs.m_topic_type))
         , m_topic_desc(std::move(rhs.m_topic_desc))
         , m_qos(rhs.m_qos)
         , m_tlayer(rhs.m_tlayer)
         , m_event_callback(std::move(rhs.m_event_callback))
         , m_id(rhs.m_id)
         , m_created(rhs.m_created)
       {
         InitializeQOS();
         InitializeTLayer();
   
         rhs.m_publisher = nullptr;
         rhs.m_created   = false;
       }
   
       CPublisher& operator=(CPublisher&& rhs)
       {
         m_publisher      = rhs.m_publisher;
         m_topic_name     = std::move(rhs.m_topic_name);
         m_topic_type     = std::move(rhs.m_topic_type);
         m_topic_desc     = std::move(rhs.m_topic_desc);
         m_qos            = rhs.m_qos;
         m_tlayer         = rhs.m_tlayer;
         m_event_callback = std::move(rhs.m_event_callback);
         m_id             = rhs.m_id;
         m_created        = rhs.m_created;
   
         InitializeQOS();
         InitializeTLayer();
         rhs.m_publisher = nullptr;
         rhs.m_created   = false;
   
         return *this;
       }
   
       bool Create(const std::string& topic_name_, const std::string& topic_type_ = "", const std::string& topic_desc_ = "")
       {
         if(m_created) return(false);
   
         // create new instance
         m_publisher = eCAL_Pub_New();
         if (!m_publisher) return(false);
   
         // set layer mode if changed class method function
         if (m_tlayer.sm_udp_mc != TLayer::smode_none) eCAL_Pub_SetLayerMode(m_publisher, static_cast<eTransportLayerC>(TLayer::tlayer_udp_mc), static_cast<eSendModeC>(m_tlayer.sm_udp_mc));
         if (m_tlayer.sm_shm    != TLayer::smode_none) eCAL_Pub_SetLayerMode(m_publisher, static_cast<eTransportLayerC>(TLayer::tlayer_shm),    static_cast<eSendModeC>(m_tlayer.sm_shm));
   
         // set qos
         struct SWriterQOSC qos;
         qos.history_kind       = static_cast<eQOSPolicy_HistoryKindC>(m_qos.history_kind);
         qos.history_kind_depth = m_qos.history_kind_depth;;
         qos.reliability        = static_cast<eQOSPolicy_ReliabilityC>(m_qos.reliability);
         eCAL_Pub_SetQOS(m_publisher, qos);
   
         // create it
         eCAL_Pub_Create(m_publisher, topic_name_.c_str(), topic_type_.c_str(), topic_desc_.c_str(), static_cast<int>(topic_desc_.size()));
   
         m_topic_name = topic_name_;
         m_topic_type = topic_type_;
         m_topic_desc = topic_desc_;
   
         m_created = true;
         return(true);
       }
   
       bool Destroy()
       {
         if(!m_created) return(false);
         if(m_publisher) eCAL_Pub_Destroy(m_publisher);
   
         m_publisher  = nullptr;
         m_topic_name = "";
         m_topic_type = "";
         m_created    = false;
         return(true);
       }
   
       bool SetDescription(const std::string& topic_desc_)
       {
         m_topic_desc = topic_desc_;
         if(!m_publisher) return(false);
         return(eCAL_Pub_SetDescription(m_publisher, topic_desc_.c_str(), static_cast<int>(topic_desc_.size())) != 0);
       }
   
       bool ShareType(bool state_ = true)
       {
         if (!m_publisher) return(false);
         return(eCAL_Pub_ShareType(m_publisher, static_cast<int>(state_)) != 0);
       }
   
       bool ShareDescription(bool state_ = true)
       {
         if (!m_publisher) return(false);
         return(eCAL_Pub_ShareDescription(m_publisher, static_cast<int>(state_)) != 0);
       }
   
       bool SetQOS(const QOS::SWriterQOS& qos_)
       {
         // can not be set after Create
         if (m_publisher) return(false);
         m_qos = qos_;
         return(true);
       }
   
       QOS::SWriterQOS GetQOS()
       {
         return(m_qos);
       }
   
       bool SetLayerMode(TLayer::eTransportLayer layer_, TLayer::eSendMode mode_)
       {
         if (!m_publisher)
         {
           switch (layer_)
           {
           case TLayer::tlayer_udp_mc:
             m_tlayer.sm_udp_mc = mode_;
             break;
           case TLayer::tlayer_shm:
             m_tlayer.sm_shm = mode_;
             break;
           case TLayer::tlayer_inproc:
             m_tlayer.sm_inproc = mode_;
             break;
           case TLayer::tlayer_all:
             m_tlayer.sm_udp_mc  = mode_;
             m_tlayer.sm_shm     = mode_;
             m_tlayer.sm_inproc  = mode_;
             break;
           default:
             break;
           }
           return(true);
         }
         else
         {
           return(eCAL_Pub_SetLayerMode(m_publisher, static_cast<eTransportLayerC>(layer_), static_cast<eSendModeC>(mode_)) != 0);
         }
       }
   
       bool SetMaxBandwidthUDP(long bandwidth_)
       {
         if (!m_publisher) return(false);
         return(eCAL_Pub_SetMaxBandwidthUDP(m_publisher, bandwidth_) != 0);
       }
   
       bool SetID(long long id_)
       {
         if (!m_publisher) return(false);
         return(eCAL_Pub_SetID(m_publisher, id_) != 0);
       }
   
       size_t Send(const void* const buf_, size_t len_, long long time_ = -1) const
       {
         if(!m_publisher) return(0);
         return(eCAL_Pub_Send(m_publisher, buf_, static_cast<int>(len_), time_));
       }
   
       size_t Send(const std::string& s_, long long time_ = -1) const
       {
         return(eCAL_Pub_Send(m_publisher, s_.data(), static_cast<int>(s_.size()), time_));
       }
   
       static void PubEventCallback(const char* topic_name_, const struct SPubEventCallbackDataC* data_, void* par_)
       {
         if (par_ == nullptr) return;
         CPublisher* pub = static_cast<CPublisher*>(par_);
         SPubEventCallbackData data;
         data.type = data_->type;
         data.time = data_->time;
         pub->m_event_callback(topic_name_, &data);
       }
       bool AddEventCallback(eCAL_Publisher_Event type_, PubEventCallbackT callback_)
       {
         if (!m_publisher) return(false);
         m_event_callback = callback_;
         return(eCAL_Pub_AddEventCallbackC(m_publisher, type_, &CPublisher::PubEventCallback, this) != 0);
       }
   
       bool RemEventCallback(eCAL_Publisher_Event type_)
       {
         if (!m_publisher) return(false);
         return(eCAL_Pub_RemEventCallback(m_publisher, type_) != 0);
       }
   
       bool IsCreated() const {return(m_created);}
   
       bool IsSubscribed() const
       {
         if(!m_publisher) return(false);
         return(eCAL_Pub_IsSubscribed(m_publisher) != 0);
       }
   
       const std::string& GetTopicName() const {return(m_topic_name);}
   
       const std::string& GetTypeName() const {return(m_topic_type);}
   
       const std::string& GetDescription() const {return(m_topic_desc);}
   
       void InitializeQOS()
       {
         m_qos.history_kind       = QOS::keep_last_history_qos;
         m_qos.history_kind_depth = 8;
         m_qos.reliability        = QOS::reliable_reliability_qos;
       }
   
       void InitializeTLayer()
       {
         m_tlayer.sm_udp_mc  = TLayer::smode_none;
         m_tlayer.sm_shm     = TLayer::smode_none;
         m_tlayer.sm_inproc  = TLayer::smode_none;
       }
   
       std::string Dump() const
       {
         if(!m_publisher) return("");
         void* buf = nullptr;
         size_t buf_len = eCAL_Pub_Dump(m_publisher, &buf, ECAL_ALLOCATE_4ME);
         if(buf_len == 0) return("");
         std::string dbuf = std::string(static_cast<char*>(buf), buf_len);
         eCAL_FreeMem(buf);
         return(dbuf);
       }
   
     protected:
       // class members
       ECAL_HANDLE             m_publisher;
       std::string             m_topic_name;
       std::string             m_topic_type;
       std::string             m_topic_desc;
       QOS::SWriterQOS         m_qos;
       TLayer::STLayer         m_tlayer;
       PubEventCallbackT       m_event_callback;
       long long               m_id;
       bool                    m_created;
     };
   };
   
   #endif /* ! ECAL_C_DLL */
